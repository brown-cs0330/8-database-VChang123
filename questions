Questions

1. Consider the thread created in start_listener. 
How many threads with this functionality should be running on the server at any given time?

    There should only be one thread with the listening functionality becuase that one thread will listen
    for clients and when it detects a client, it will create a client thread for it using the 
    client_constructor function and then detach it to run the clients actions. 
    We do not need more than one listener thread becuase one thread would be enough 
    to create all the client threads.
   
2. In the listener function, what do each of the following fields of the 
sockaddr_in struct represent: sin_family, sin_port, and sin_addr.s_addr?

    sin_family: Represents the communication domain the addresses are in. So in start_listener the sin_family
        is AF_INET which is IPv4.
    sin_port: Gets the port of the server and converts it from host to network(short). The server
        will run a port number and the client will run the same port number to be able to interact
        withe each other. comm_port is the port that is determined by the input to the server.
        So in start_listener the sin_port = htons(comm_port);
    sin_addr.s_addr: stores all the address on the machine becuase a machine might have
        mutiple address. It stores the "wildcard" address which is all the address on the machine 
        so we may be abloe to receive on all interfaces. 
        In start_listener the sin_addr.s_addr = htonl(INADDR_ANY). htonl means convert from host to network
        long.

3. What is the purpose of each of the following function calls in listener: 
socket, bind, listen, and accept? You should explain what each call does and 
what the effect would be if it were not called.

    socket: Sockets are the abstraction of the communication path or a communication endpoing.
        socket() sets up a socket which is the basis for communication and
        refers to it using a file descriptor. If this function were not called then
        there would not be an endpoint of commuication and the server would not be 
        able to communicate with another network.

    bind: The bind function binds the file descriptor returned by socket() to the address
        of our machine. If the file descriptor is not binded to a an address then
        there is not a specified place for a server port to be open. Binding to a
        specific address makes the server port only visible to the network connected to the local host.
    
    listen: The listen function tells the Operating System that the process would like to 
        receive connections from clients using the indicated socket. The first parameter is a 
        socket file descriptor, and the second parameter is the maximum number of connections that may 
        be queued up. If the listner function is not called then the socket will not be able access
        clients using the indicated socket.

    accept: The accept system call waits if necessary for a connected socket to appear on the
        the listening socket's queue, then pulls the first such socket from the queue. This socket
        is the server end of a connection from a client. A file descriptor is returned that refers
        to that socket, alloding the process to now communicate withe communicate. If accept is not
        used then the process would not be able to communicate with the client.

4. Which protocol (TCP or UDP) is used for communication? 
Why is this protocol used? (Hint: see line 35 in comm.c)

    The protocol used for communication is TCP because SOCK_STREAM is TCP. TCP is used 
    becuase it is reliable transmission and UDP is unreliable transmission. TCP is
    also a better a choice for a database because it guarantees the integrity of data. 
    Because we are creating a database we want all of our data to be intact and TCP ensures
    that. UDP is an unreliable becuase it may or may not lose dats during transmission
    which makes it not optimal for a database.



5. Describe what comm_serve does. How are the response and 
command parameters used? What would happen if the stream pointed to by cxstr were closed?

    comm_serve is in charge of the communication. It first checks if there is anything in
    the response buffer. If there is a response, then that means there is an output from
    the server that needs to be sent to the client, so by using fputs(), we can write to the cxstr
    file. If there is nothing in the response buffer, then fgets() is called to see if 
    there is a command avaible to excute. If the stream pointed to by cxstr is closed that means there
    is no file to write to and the connection with the client will be terminated.


6. Describe, in detail, what happens during each iteration of 
the while loop in the listener function. Be sure to include explanations of all 
significant function calls.

    In each iteration the first function call is accept() which waits to see if there is a client 
    socket waiting to be connected. If there is, then that socket is pulledfrom the queue
    and a connection is created, returning a file descriptor that can be used to communicate to the client.
    If accept() has failed, then we move onto the next iteration of the while loop. If accept()
    is successful, we open the file stream using fdopen(), giving it read and write permission. 
    If the file exist we will use that, otherwise it will be created. If fopen() fails, the socket
    will be closed and we move onto the next interation of the while loop.
    Then the call to server() establishes a client which has I/O stream pointed to by cxstr. Then
    we can move onto the next iteration.
